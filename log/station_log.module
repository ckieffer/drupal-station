<?php
// $Id: station_log.module,v 1.24 2010/01/28 00:00:00 thumb Exp $

/*
 1) Update recently played block list via Ajax.
 2) Get shoutcast current track to show in block if it hasn't been logged yet.
 3) Handle multiple schedules. Need to link station schedules to SHOUTcast admin urls.
 4) Integrate with amazon.module to retrive album cover image URLs.
 5) Add weekly charts, new and popular this week blocks (separate module?)
 6) Create "album/song not found" in MusicBrainz report.
 7) Adjust time for the user's timezone (see station_nowplaying)
 8) What to do on multi-artist albums (compilations)?
 9) Add LinkShare search affiliate links for iTunes.
10) Validate song names against MusicBrainz.
11) Look into getting and setting genre for station_catalog items, does MusicBrainz provide genre?
12) Add views support.
*/

/**
 * Implementation of hook_help().
 */
function station_log_help($path, $arg) {
  switch ($path) {
    case 'admin/settings/station/log':
      return t("Logs track metadata from SHOUTcast streams.");
  }
}

/**
 * Implementation of hook_perm().
 */
function station_log_perm() {
  return array(
    'administer station log',
    'access station log content'
  );
}

/**
 * Implementation of hook_access().
 */
function station_log_access($op, $node, $account) {
  if (user_access('administer station log', $account)) {
    return TRUE;
  }
  switch ($op) {
    case 'view':
      return user_access('view station log content', $account);
  }
}

/**
 * Implementation of hook_menu().
 */
function station_log_menu() {
  $items['admin/settings/station/log'] = array(
          'title' => 'Log',
          'page callback' => 'drupal_get_form',
          'page arguments' => array('station_log_admin_settings'),
          'access arguments' => array('administer site configuration'),
          'file' => 'station_log.admin.inc',
          'type' => MENU_LOCAL_TASK
  );
  $items['station/log/update'] = array(
          'title' => 'Update the station log',
          'description' => 'Update the station log',
          'page callback' => 'station_log_update_page',
          'access arguments' => array('access station log content'),
          'type' => MENU_CALLBACK,
  );
  $items['station/log/recent'] = array(
          'title' => variable_get('station_log_page_subject', t('Recently played')),
          'description' => 'View songs recently played',
          'page callback' => 'station_log_recent_page',
          'access arguments' => array('access station log content'),
          'type' => MENU_NORMAL_ITEM,
  );
  // @todo limit access to admins
//  $items['station/log/duplicates'] = array(
//          'title' => 'Duplicate Albums and Tracks',
//          'description' => '',
//          'page callback' => 'station_log_fix_duplicates_page',
//          'access arguments' => array('access station log content'),
//          'type' => MENU_CALLBACK
//  );
  return $items;
}

/**
 * Implementation hook_cron().
 */
function station_log_cron() {

}

/**
 * Get the most recent timestamp for logged tracks.
 *
 * @param
 *   A station schedule nid.
 *
 * @return
 *   UNIX timestamp
 */
function station_log_get_max_timestamp($schedule_nid) {
  $result = db_query('SELECT MAX(timestamp) AS timestamp FROM {station_log} WHERE schedule_nid = %d', $schedule_nid);
  $array = db_fetch_array($result);
  return $array['timestamp'];
}

/**
 * Pull an array of tracks from a SHOUTcast song history object.
 *
 * @return
 *   An associative track history array
 */
function station_log_get_shoutcast_tracks() {
  $xml = shoutcast_get_xml();
  $history = $xml->SONGHISTORY;
  foreach($history->SONG as $key => $track) {
    $parts = explode(' - ', $track->TITLE);
    $tracks[(int) $track->PLAYEDAT] = array(
        'artist' => trim($parts[0]),
        'title' => trim($parts[1]),
        'album' => trim($parts[2]),
        'label' => trim($parts[3]),
        'raw' => (string) $track->TITLE,
      );
  }
  return $tracks;
}

/**
 * Get album id from station catalog, if the album doesn't exist, add it.
 *
 * @param $track
 *   Track info, including artist, album, title, and label.
 *
 * @return
 *   A station_catalog album's nid.
 */
function station_log_album($track) {
  // Do we have the album in the catalog already?
  $node = db_fetch_object(db_query("SELECT MIN(nid) AS nid, artist, album, label FROM {station_catalog} WHERE artist = '%s' AND album = '%s'", $track['artist'], $track['album']));

  // If not, insert this as a new album
  if (!$node->nid) {
    if (!empty($track['artist']) && !empty($track['album'])) {
      $node = new stdClass();
      $node->type = 'station_album';
      $node->title = $track['artist'] . ' - ' . $track['album'];
      $node->uid = 1;
		  $node->album['artist'] = $track['artist'];
		  $node->album['album'] = $track['album'];
		  $node->album['label'] = $track['label'];
      $node->album['number'] = station_catalog_album_next_number();
      $node = station_catalog_update_album_from_musicbrainz($node);
      node_save($node);
    }
  }
  return (!empty($node->nid)) ? $node->nid : false;
}

/**
 * Get songs played from the stream and log them.
 *
 * @param
 *   A station schedule nid.
 *
 * @return
 *   The number tracks logged.
 */
function station_log_new_tracks($schedule_nid) {
  // Get SHOUTcast SONGHISTORY, reverse the order and preserve the keys
  $tracks = array_reverse(station_log_get_shoutcast_tracks(), true);

  // Get last timestamp logged from the station log, we'll only log tracks since then
  $max_timestamp = station_log_get_max_timestamp($schedule_nid);

  // Count the number of songs logged
  $tracks_logged = 0;

  // Loop through and log each new track
  foreach ($tracks as $timestamp => $track) {
    if (empty($max_timestamp) || $timestamp > $max_timestamp) {
      // Get the album nid from station catalog, add it if new
      $track['catalog_nid'] = station_log_album($track);

      // Log the track id
      if ($track['catalog_nid']) {
        station_log_add($schedule_nid, $timestamp, $track);
        $tracks_logged++;
      }
    }
  }
  watchdog('station_log', "Logged $tracks_logged tracks.", NULL, WATCHDOG_INFO);

  return $tracks_logged;
}

/**
 * Add a track to station_log.
 *
 * @param
 *   A station schedule nid.
 *
 * @param $timestamp
 *    The date and time the track was played as a Unix timestamp.
 *
 * @param $track
 *    An array containing track info.
 */
function station_log_add($schedule_nid, $timestamp, $track) {
  $track_nid = db_result(db_query("SELECT track_nid FROM {station_log_track} WHERE catalog_nid = %d AND title = '%s'", $track['catalog_nid'], $track['title']));

  if (!$track_nid) {
    $track_nid = station_log_track_add($track);
  }
  if ($track_nid > 0) {
    db_query("INSERT INTO {station_log} (schedule_nid, timestamp, track_nid) VALUES (%d, %d, %d)", $schedule_nid, $timestamp, $track_nid);
  }
}

/**
 * Add a track to station_log_track.
 *
 * @param $track
 *   An array containing an individual track's catalog_nid and song title.
 *
 * @return
 *   The logged track's track_nid.
 */
function station_log_track_add($track) {
  db_query("INSERT INTO {station_log_track} (catalog_nid, title) VALUES (%d, '%s')", $track['catalog_nid'], $track['title']);
  return db_last_insert_id('drpl_station_log_track', 'track_nid');
}

/**
 * Provide a page to call from cron to update the log without running hook_cron().
 */
function station_log_update_page() {
  // Get the first web stream found to set the default shoutcast history url
  $schedule_nid = variable_get('station_schedule_default', 0);
  $tracks_logged = station_log_new_tracks($schedule_nid);
  return t("Added $tracks_logged tracks to the station log.");
}

/**
 * Display titles played during the past N hours.
 */
function station_log_recent_page() {
  drupal_add_css(drupal_get_path('module', 'station_log') .'/station_log.css');
  $limit = variable_get('station_log_page_limit', 6);
  $tracks = station_log_get_recent_tracks($limit, 'hours');
  $fields = station_log_display_fields('page');
  $list = station_log_track_list($tracks, $fields, 'page');
  return $list;
}

/**
 * Implementation of hook_block().
 */
function station_log_block($op = 'list', $delta = 0) {
  drupal_add_css(drupal_get_path('module', 'station_log') .'/station_log.css');

  if ($op == 'list') {
    $block[0]['info'] = t('Station log recently played');
    return $block;

  } elseif ($op == 'view') {
    $block['content'] = '';
    $limit = variable_get('station_log_block_limit', 5);
    $tracks = station_log_get_recent_tracks($limit, null);
    $fields = array('artist', 'title');
    $fields = station_log_display_fields('block');

    $block['subject'] = variable_get('station_log_block_subject', t('Recently played'));
    $block['content'] = station_log_track_list($tracks, $fields, 'block');
    $block['content'] .= '<a href="http://' . $_SERVER['HTTP_HOST'] .
          base_path() . 'station/log/recent" class="more">more</a>';
  }
  return $block;
}

/**
 * Get recent tracks played, either a track count or tracks played in the past N hours.
 *
 * @param $limit
 *   Number of tracks to return, either a track count or an hour count
 *
 * @param $unit
 *   The unit of measure, 'hours' or null to set count
 *
 * @return
 *    A database result object containing a list of songs
 */
function station_log_get_recent_tracks($limit, $unit) {
  $args[] = variable_get('station_schedule_default', 0);
  $query = "SELECT l.timestamp, lt.title, c.artist, c.album, c.label, c.asin
      FROM {station_log} l
      JOIN {station_log_track} lt ON lt.track_nid = l.track_nid
      JOIN {station_catalog} c ON c.nid = lt.catalog_nid
      WHERE l.schedule_nid = %d";
  $order_by = "ORDER BY l.timestamp DESC";
  if ($unit == 'hours') {
    $args[] = (mktime() - ($limit * 3600));
    $tracks = db_query("$query AND l.timestamp > %d $order_by", $args);
  } else {
    $tracks = db_query_range("$query $order_by", $args, 0, $limit);
  }
  return $tracks;
}

/**
 * Format a list of tracks as an HTML unordered list.
 *
 * @param $tracks
 *    An object containing a list of tracks to format
 *
 * @param $fields
 *    An array containing which fields to display (time, artist, title, album, label)
 *
 * @return
 *    An HTML unordered list
 */
function station_log_track_list($tracks, $fields, $context) {
  $list = '<ul class="station-log">';
  while ($track = db_fetch_object($tracks)) {
    $item = array();
    if ($fields['datetime'] && !empty($track->timestamp)) {
      $date_format = variable_get("station_log_{$context}_dateformat", 'h:i');
      $item[] = '<span class="datetime">' . date($date_format, $track->timestamp) . '</span>';
    }
    $item[] = '<span class="artist">' . $track->artist . '</span>';
    $item[] = '<span class="title">' . $track->title . '</span>';
    if ($fields['album'] && !empty($track->album)) {
      $item[] = '<span class="album">' . $track->album . '</span>';
    }
    if ($fields['label'] && !empty($track->label)) {
      $item[] = '<span class="label">' . $track->label . '</span>';
    }
    if ($buy_link = station_log_buy_amazon_link($track)) {
      $list .= '<li>' . $buy_link . implode(' - ', $item) . '</li>';
    } else {
      $list .= '<li>' . implode(' - ', $item) . '</li>';
    }
  }
  $list .= '</ul>';
  return $list;
}

/**
 * Create a "buy" from Amazon link for albums and artists.
 *
 * @param $track
 *    An object containing a track's title, artist, album, etc.
 *
 * @return
 *    A link to either an Amazon detail page or an artist search
 */
function station_log_buy_amazon_link($track) {
  $affiliate_code = variable_get('amazon_custom_associate_id', 0);
  if ($affiliate_code) {
    if (!empty($track->asin)) {
      $link = "http://amazon.com/gp/product/$track->asin?ie=UTF8&tag=$affiliate_code&linkCode=as2&camp=1789&creative=9325&creativeASIN=$track->asin";
      $title = t("Buy $track->album by $track->artist from Amazon.com");
    }
    else {
      $keyword = urlencode($track->artist . ' ' . $track->album);
      $link = "http://amazon.com/exec/obidos/redirect?tag=$affiliate_link&creative=9325&camp=1789&link_code=ur2&path=external-search%3Fsearch-type%3Dss%26index%3Dmusic%26keyword%3D$keyword";
      $title = t("Buy music by $track->artist from Amazon.com");
    }
    return "<a href=\"$link\" class=\"station-log-buy-button\" target=\"_blank\" title=\"$title\">" . t('buy') . "</a>";

  }
  else {
    return false;
  }
}

/**
 * Remove duplicate station_catalog album nodes and duplicate station_log_tracks. In each case,
 * update station_log_track and station_log respectively to maintain album links and track links.
 */
function station_log_fix_duplicates_page() {
  $page = '';
  // Select duplicate album entries for individual artists
  // This ignores shared album names among multiple artists (soundtracks, compilations, etc.)
  $duplicate_albums = db_query("SELECT nid, artist, album, COUNT(album) AS album_count
    FROM {station_catalog}
    GROUP BY artist, album
    HAVING album_count > 1
    ORDER BY album, nid DESC");

  $album_count = 0;
  $album_list = '';

  while ($album = db_fetch_object($duplicate_albums)) {
    $album_list .= "<li>$album->album by $album->artist appears $album->album_count times.";

    // Select each duplicate album
    $album_instances = db_query("SELECT nid FROM {station_catalog}
      WHERE artist = '%s' AND album = '%s' ORDER BY nid", $album->artist, $album->album);

    // Update logged track's album ids, set them to the first instance of the duplicated album
    $album_nids = array();
    $first_album_nid = null;

    while ($duplicate_album = db_fetch_object($album_instances)) {
      // Keep the first album
      if (is_null($first_album_nid)) {
        $first_album_nid = $duplicate_album->nid;
      }
      else {
        // Set logged track's album nid to the first instance of the duped album
        db_query("UPDATE {station_log_track} SET catalog_nid = %d WHERE catalog_nid = %d", $first_album_nid, $duplicate_album->nid);
        // Delete duplicate albums
        node_delete($duplicate_album->nid);
      }
      // Collect the album nids for display, the first nid is kept while others are deleted
      $album_nids[] = $duplicate_album->nid;
    }
    $album_nids = '(' . implode(', ', $album_nids) . ')<br>';
    $album_list .= " $album_nids</li>";
    $album_count++;
  }
  $page .= "<h2>$album_count Duplicate Albums</h2><ul>$album_list</ul>";

  //
  $duplicate_tracks = db_query("SELECT t.track_nid, t.catalog_nid, c.artist, t.title, c.album, COUNT(t.title) AS track_count
    FROM {station_log_track} t JOIN {station_catalog} c ON c.nid = t.catalog_nid
    GROUP BY c.artist, t.title
    HAVING track_count > 1
    ORDER BY c.artist, t.title DESC");

  $track_count = 0;
  $track_list = '';

  while ($track = db_fetch_object($duplicate_tracks)) {
    $track_list .= "<li>$track->title by $track->artist appears $track->track_count times.";

    // Select each duplicate track
    $track_instances = db_query("SELECT l.track_nid
      FROM {station_log} l
        JOIN drpl_station_log_track t ON t.track_nid = l.track_nid
        JOIN drpl_station_catalog c ON c.nid = t.catalog_nid
      WHERE t.title = '%s' AND t.catalog_nid = %d
      ORDER BY track_nid", $track->title, $track->catalog_nid);

    // Update logged track's ids, set them to the first instance of the duplicated track
    $track_nids = array();
    $first_track_nid = null;

    while ($duplicate_track = db_fetch_object($track_instances)) {
      // Keep the first track
      if (is_null($first_track_nid)) {
        $first_track_nid = $duplicate_track->track_nid;
      }
      else {
        // Set duplicate logged tracks nid's to the first instance of the duped track
        db_query("UPDATE {station_log} SET track_nid = %d WHERE track_nid = %d", $first_track_nid, $duplicate_track->track_nid);
        // Delete duplicate the tracks
        db_query("DELETE FROM {station_log_track} WHERE track_nid = %d", $duplicate_track->track_nid);
      }
      // Collect the track nids for display, the first nid is kept while others are deleted
      $track_nids[] = $duplicate_track->track_nid;
    }
    $track_nids = '(' . implode(', ', $track_nids) . ')<br>';
    $track_list .= " $track_nids</li>";
    $track_count++;
  }
  $page .= "<h2>$track_count Duplicate Tracks</h2><ul>$track_list</ul>";

  return $page;
}

/**
 * Get/set which fields to display on the page or block
 *
 * @param $context
 *   Either 'block' or 'page'
 *
 * @return
 *    An array of display field settings
 */
function station_log_display_fields($context) {
  $fields = variable_get("station_log_{$context}_display_fields", array(
      'datetime',
      'album',
      'label',
    )
  );
  return $fields;
}
